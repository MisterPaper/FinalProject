Adiel Roytgarts
100068220
aroytgarts1@myseneca.ca

This project overall was the most complicated project I have programmed, over the course of multiple weeks. I learned about custom types, operator overloading, dynamic memory, polymorphism, modifying files, input/output, and more. I did this through creating many types throughout all the milestones (first with PosApp, then Error and Date, Item) which all involved dynamic memory and custom types. Item itself was inherited from an abstract class PosIO, and Item was an abstract class as well. For these I had to program operator overloads and follow the rule of three for all types which managed resources. Then, I started doing more polymorphism when I implemented 2 classes that inherited from Item: NonPerishable and Perishable. The specific type of polymorphism I did in these workshops was inclusion polymorphism, as the same function had a multitude of definitions across the inheritance hierachy depending on the type. I did consider using parametric polymorphism, however I did not find a use for it in the time I spent working on my project. 

As for the difficulty, it was varied. Some milestones were pretty easy while others involved nights of debugging. The main difficulty arose wherever I had to implement input / output as there were many things that could go wrong. First was if the user wrote bad data, my program would crash. I had to carefully design my functions to be so rigorous to let the user type in almost anything they could imagine. As well, I had to carefully manage the stream so that my cin object did not accidentally capture the wrong information at the wrong time. This involved lots of cin.ignore()'s, and cin.clear()'s for when the user typed in bad data. The same was true for file input and output. 

Throughout the project I also had difficulty with the complexity of it all. I had 2 types NonPerishable and Perishable that inherited from Item, which itself was an abstract type inherited from PosIO, which contained 2 classes Error and Date, and used functions from another class Utils.cpp. That alone involved seven different classes. On top of that, I had to have a polymorphic array in yet another class that contained both NonPerishable and Perishable types. So I had to code my class to be able to manage a polymorphic type, which involved lots of pointer use which was not easy. And there were times where a function broke in one of my classes and I had to go on a rabbit hole down all my classes to find where the error was coming from. 